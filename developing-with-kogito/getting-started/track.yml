slug: developing-with-kogito-getting-started
id: 7tdsxmrdskia
type: track
title: Getting Started with Kogito
description: |
  In this scenario, you will get an introduction to business automation using [Kogito](https://kogito.kie.org).

  ## What is Kogito?

  ![Logo](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/logo.png)

  ### Cloud Native Business Automation

  Business Automation covers the application area of business processes, workflows, decisions, rules and optimization. Kogito brings these capabilities to the Cloud Native world by utilizing the latest innovations in the Java landscape, like [Quarkus](https://quarkus.io) and [GraalVM](https://graalvm.org), while building on battle-tested components.

  The introduction of the microservices architectural style, and the rapid move to containers and cloud, has introduced new requirements for business applications. Decision and process logic form a large part of an enterprises IT landscape. The move to these new, highly distributed, application environments requires a new form of process automation and decision management. A form of business automation that utilizes concepts like microservices, reactive and event-driven applications, and serverless deployments and execution.

  Kogito has been designed with this new world in mind, and provides first-class support for these different paradigms. The Kogito development model morphs to adapt itself to the type of application you are developing.

  Kogito is a a Cloud Native Business Automation stack targetted at modern runtimes like [Quarkus](https://quarkus.io) and [Spring Boot](https://spring.io/projects/spring-boot). It's built on battle-tested capabilities like [Drools](https://www.drools.org), [jBPM](https://www.jbpm.org) and [OptaPlanner](https://www.optaplanner.org). Amazingly fast boot time, incredibly low RSS memory (not just heap size!) offering near instant scale up and high density memory utilization in container orchestration platforms like Kubernetes.

  ### Kogito ergo Cloud

  Kogito is designed from ground up to run at scale on cloud infrastructure. If you think about business automation think about the cloud, as this is where your business logic lives these days. By taking advantage of the latest technologies (Quarkus, knative, etc.), you get amazingly fast boot times and instant scaling on orchestration platforms like Kubernetes.

  ### Kogito ergo Domain

  Kogito adapts to your business domain rather than the other way around. No more leaking abstraction of the tool into your client applications. Stay focused on what the business is about, instead of being concerned with technology behind it.

  ### Kogito ergo Power
  Kogito offers a powerful developer experience based on battle-tested components. Achieve instant developer efficiency by having:

  * Tooling embeddable wherever you need it
  * Code generation taking care of 80% of the work
  * Flexibility to customize, only use what you need
  * Simplified local development with live reload

  ### Other possibilities

  Learn more at [kogito.kie.org](https://kogito.kie.org), or just drive on and get hands-on!
icon: https://logodix.com/logo/1910931.png
level: beginner
tags:
- openshift
owner: openshift
developers:
- nvinto@redhat.com
- rjarvine@redhat.com
- dahmed@redhat.com
- kmacedovarela@gmail.com
private: true
published: true
challenges:
- slug: 01-create-project
  id: ydolnb5a9183
  type: challenge
  title: Step 1
  notes:
  - type: text
    contents: |
      In this scenario, you will get an introduction to [Kogito](https://kogito.kie.org).

      ## What is Kogito?

      ![Logo](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/logo.png)

      ### Cloud Native Business Automation

      Business Automation covers the application area of business processes, workflows, decisions, rules and optimization. Kogito brings these capabilities to the Cloud Native world by utilizing the latest innovations in the Java landscape, like [Quarkus](https://quarkus.io) and [GraalVM](https://graalvm.org), while building on battle-tested components.

      The introduction of the microservices architectural style, and the rapid move to containers and cloud, has introduced new requirements for business applications. Decision and process logic form a large part of an enterprises IT landscape. The move to these new, highly distributed, application environments requires a new form of process automation and decision management. A form of business automation that utilizes concepts like microservices, reactive and event-driven applications, and serverless deployments and execution.

      Kogito has been designed with this new world in mind, and provides first-class support for these different paradigms. The Kogito development model morphs to adapt itself to the type of application you are developing.

      Kogito is a a Cloud Native Business Automation stack targetted at modern runtimes like [Quarkus](https://quarkus.io) and [Spring Boot](https://spring.io/projects/spring-boot). It's built on battle-tested capabilities like [Drools](https://www.drools.org), [jBPM](https://www.jbpm.org) and [OptaPlanner](https://www.optaplanner.org). Amazingly fast boot time, incredibly low RSS memory (not just heap size!) offering near instant scale up and high density memory utilization in container orchestration platforms like Kubernetes.

      ### Kogito ergo Cloud

      Kogito is designed from ground up to run at scale on cloud infrastructure. If you think about business automation think about the cloud, as this is where your business logic lives these days. By taking advantage of the latest technologies (Quarkus, knative, etc.), you get amazingly fast boot times and instant scaling on orchestration platforms like Kubernetes.

      ### Kogito ergo Domain

      Kogito adapts to your business domain rather than the other way around. No more leaking abstraction of the tool into your client applications. Stay focused on what the business is about, instead of being concerned with technology behind it.

      ### Kogito ergo Power
      Kogito offers a powerful developer experience based on battle-tested components. Achieve instant developer efficiency by having:

      * Tooling embeddable wherever you need it
      * Code generation taking care of 80% of the work
      * Flexibility to customize, only use what you need
      * Simplified local development with live reload

      ### Other possibilities

      Learn more at [kogito.kie.org](https://kogito.kie.org), or just drive on and get hands-on!
  assignment: |
    In this step, you will create a Kogito application skeleton.


    # Create a basic project

    The easiest way to create a new Kogito project is to execute the Maven command below by clicking on it:

    `mvn archetype:generate \
      -DinteractiveMode=false \
      -DarchetypeGroupId=org.kie.kogito \
      -DarchetypeArtifactId=kogito-quarkus-archetype \
      -DarchetypeVersion=0.9.0 \
      -DgroupId=org.acme \
      -DartifactId=getting-started \
      -Dversion=1.0-SNAPSHOT`

    This will use the Kogito Quarkus Archetype and generate a basic Maven project for you in the `getting-started` subdirectory, generating:

    * The Maven structure.
    * Example `test-process.bpmn2` BPMN2 process definition.
    * An OpenAPI Swagger-UI at `http://localhost:8080/swagger-ui`.

    Once generated, look at the `getting-started/pom.xml`. You will find the import of the Kogito BOM, allowing to omit the version on the different Kogito and Quarkus dependencies. In addition, you can see the `quarkus-maven-plugin`, which is responsible for packaging of the application as well as allowing to start the application in development mode.

    ```xml
    <dependencyManagement>
      <dependencies>
        <dependency>
          <groupId>org.kie.kogito</groupId>
          <artifactId>kogito-quarkus-bom</artifactId>
          <version>${kogito.version}</version>
          <type>pom</type>
          <scope>import</scope>
        </dependency>
      </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>io.quarkus</groupId>
                <artifactId>quarkus-maven-plugin</artifactId>
                <version>1.3.0.Final</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>build</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
    ```

    If we focus on the dependencies section, you can see we are using the Kogito Quarkus extension, which enables the development of Kogito applications on Quarkus:
    ```xml
    <dependency>
      <groupId>org.kie.kogito</groupId>
      <artifactId>kogito-quarkus</artifactId>
    </dependency>
    ```

    # Running the Application

    First, change to the directory in which the project was created:

    ```
    cd /root/projects/kogito/getting-started
    ```

    Now we are ready to run our application. Click on the following command to start the application in _dev-mode_:

    ```
    mvn clean compile quarkus:dev
    ```

    You should see:

    ```console
    2020-02-07 09:09:12,440 INFO  [io.quarkus] (main) getting-started 1.0-SNAPSHOT (running on Quarkus 1.2.0.Final) started in 5.850s. Listening on: http://0.0.0.0:8080
    2020-02-07 09:09:12,447 INFO  [io.quarkus] (main) Profile dev activated. Live Coding activated.
    2020-02-07 09:09:12,449 INFO  [io.quarkus] (main) Installed features: [cdi, kogito, resteasy, resteasy-jackson, smallrye-openapi, swagger-ui]
    ```

    Because this is the first Maven Kogito/Quarkus build on this environment, the system first needs to download a number of dependencies, which can take some time.

    After the dependencies have been downloaded, and the application has been compiled, note the amazingly fast startup time! Once started, you can request the provided Swagger UI in the browser [using this link](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/swagger-ui).

    You should see the following page, which shows the API of the sample Kogito _Greetings_ service provided by the archetype:

    ![New Kogito Quarkus Web Page](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/new-kogito-quarkus-swagger-ui.png)

    It's working!

    # Congratulations!

    You've seen how to create the skeleton of basic Kogito app, package it and start it up very quickly in `quarkus:dev` mode. We'll leave the app running and rely on hot reload for the next steps.

    In the next step we'll create a BPMN2 process definition to demonstrate Kogito's code generation, hot-reload and workflow capabilities.
  tabs:
  - title: Terminal 1
    type: terminal
    hostname: crc
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 100
- slug: 02-implement-process
  id: pl12jxq3uab3
  type: challenge
  title: Step 2
  assignment: |
    In the previous step you've created a skeleton Kogito application with Quarkus. In this step we'll create our first process definition in BPMN2. We will see how Kogito is able to generate a microservice, including RESTful resources, from our business assets (e.g. process definitions, decisions, etc.).

    ## Create a process definition

    Let’s modify the application and add a process definition.

    We will create a simple process that will look like this:

    ![Process](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/kogito-getting-started-process.png)

    Open a new BPMN2 file by clicking: `getting-started/src/main/resources/getting-started.bpmn`

    BPMN2 allows us to define a graphical representation of a process (or workflow), and as such, we need a BPMN2 editor to implement our process. Kogito provides an online BPMN2 editor that we can use to build our process.

    Click on the "Kogito BPMN Tooling" tab next to the "OpenShift Console" tab to open the Kogito BPMN Tooling, or navigate to: https://bpmn.new

    Implement the process as shown in the following video. Make sure to use `getting_started` for the **name** and **id** of the process and `org.acme` for the **package**.

    https://youtu.be/babjHSNrZBg

    After you've defined your process, click on the **File Actions -> Copy source** button to copy the BPMN2 XML definition to your clipboard.

    Copy the content of your clipboard to the `getting-started/src/main/resources/getting-started.bpmn` file you've created and opened earlier using `Ctrl+v ` or `Command-v` (depending on your type of computer).

    Alternatively, you can copy the following BPMN2 definition to the BPMN file:

    <pre class="file" data-filename="./getting-started/src/main/resources/getting-started.bpmn" data-target="replace">
    &lt;bpmn2:definitions xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:bpmn2=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot; xmlns:bpmndi=&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot; xmlns:bpsim=&quot;http://www.bpsim.org/schemas/1.0&quot; xmlns:dc=&quot;http://www.omg.org/spec/DD/20100524/DC&quot; xmlns:di=&quot;http://www.omg.org/spec/DD/20100524/DI&quot; xmlns:drools=&quot;http://www.jboss.org/drools&quot; id=&quot;_3B7B4D14-4B20-497A-868A-D7B55CD93887&quot; exporter=&quot;jBPM Process Modeler&quot; exporterVersion=&quot;2.0&quot; targetNamespace=&quot;http://www.omg.org/bpmn20&quot;&gt;
      &lt;bpmn2:itemDefinition id=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_SkippableInputXItem&quot; structureRef=&quot;Object&quot;/&gt;
      &lt;bpmn2:itemDefinition id=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_PriorityInputXItem&quot; structureRef=&quot;Object&quot;/&gt;
      &lt;bpmn2:itemDefinition id=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_CommentInputXItem&quot; structureRef=&quot;Object&quot;/&gt;
      &lt;bpmn2:itemDefinition id=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_DescriptionInputXItem&quot; structureRef=&quot;Object&quot;/&gt;
      &lt;bpmn2:itemDefinition id=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_CreatedByInputXItem&quot; structureRef=&quot;Object&quot;/&gt;
      &lt;bpmn2:itemDefinition id=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_TaskNameInputXItem&quot; structureRef=&quot;Object&quot;/&gt;
      &lt;bpmn2:itemDefinition id=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_GroupIdInputXItem&quot; structureRef=&quot;Object&quot;/&gt;
      &lt;bpmn2:itemDefinition id=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_ContentInputXItem&quot; structureRef=&quot;Object&quot;/&gt;
      &lt;bpmn2:itemDefinition id=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_NotStartedReassignInputXItem&quot; structureRef=&quot;Object&quot;/&gt;
      &lt;bpmn2:itemDefinition id=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_NotCompletedReassignInputXItem&quot; structureRef=&quot;Object&quot;/&gt;
      &lt;bpmn2:itemDefinition id=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_NotStartedNotifyInputXItem&quot; structureRef=&quot;Object&quot;/&gt;
      &lt;bpmn2:itemDefinition id=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_NotCompletedNotifyInputXItem&quot; structureRef=&quot;Object&quot;/&gt;
      &lt;bpmn2:process id=&quot;getting_started&quot; drools:packageName=&quot;org.acme&quot; drools:version=&quot;1.0&quot; drools:adHoc=&quot;false&quot; name=&quot;getting_started&quot; isExecutable=&quot;true&quot; processType=&quot;Public&quot;&gt;
        &lt;bpmn2:sequenceFlow id=&quot;_3B95A0A8-3313-487C-A14E-972E04D228B5&quot; sourceRef=&quot;_8C980097-4DBD-4BAF-B991-73EC1419E8CE&quot; targetRef=&quot;_3F791B0E-1549-441F-AA55-B70154E227B2&quot;&gt;
          &lt;bpmn2:extensionElements&gt;
            &lt;drools:metaData name=&quot;isAutoConnection.source&quot;&gt;
              &lt;drools:metaValue&gt;true&lt;/drools:metaValue&gt;
            &lt;/drools:metaData&gt;
            &lt;drools:metaData name=&quot;isAutoConnection.target&quot;&gt;
              &lt;drools:metaValue&gt;true&lt;/drools:metaValue&gt;
            &lt;/drools:metaData&gt;
          &lt;/bpmn2:extensionElements&gt;
        &lt;/bpmn2:sequenceFlow&gt;
        &lt;bpmn2:sequenceFlow id=&quot;_D96968A8-096F-441E-BEF5-69B5EB7B1C91&quot; sourceRef=&quot;_3872BDA1-71C9-49B4-B15F-9800547FEA0A&quot; targetRef=&quot;_8C980097-4DBD-4BAF-B991-73EC1419E8CE&quot;&gt;
          &lt;bpmn2:extensionElements&gt;
            &lt;drools:metaData name=&quot;isAutoConnection.source&quot;&gt;
              &lt;drools:metaValue&gt;true&lt;/drools:metaValue&gt;
            &lt;/drools:metaData&gt;
            &lt;drools:metaData name=&quot;isAutoConnection.target&quot;&gt;
              &lt;drools:metaValue&gt;true&lt;/drools:metaValue&gt;
            &lt;/drools:metaData&gt;
          &lt;/bpmn2:extensionElements&gt;
        &lt;/bpmn2:sequenceFlow&gt;
        &lt;bpmn2:endEvent id=&quot;_3F791B0E-1549-441F-AA55-B70154E227B2&quot;&gt;
          &lt;bpmn2:incoming&gt;_3B95A0A8-3313-487C-A14E-972E04D228B5&lt;/bpmn2:incoming&gt;
        &lt;/bpmn2:endEvent&gt;
        &lt;bpmn2:userTask id=&quot;_8C980097-4DBD-4BAF-B991-73EC1419E8CE&quot; name=&quot;Task&quot;&gt;
          &lt;bpmn2:extensionElements&gt;
            &lt;drools:metaData name=&quot;elementname&quot;&gt;
              &lt;drools:metaValue&gt;Task&lt;/drools:metaValue&gt;
            &lt;/drools:metaData&gt;
          &lt;/bpmn2:extensionElements&gt;
          &lt;bpmn2:incoming&gt;_D96968A8-096F-441E-BEF5-69B5EB7B1C91&lt;/bpmn2:incoming&gt;
          &lt;bpmn2:outgoing&gt;_3B95A0A8-3313-487C-A14E-972E04D228B5&lt;/bpmn2:outgoing&gt;
          &lt;bpmn2:ioSpecification id=&quot;_FdyD4AJMEDiMpvp3hRnB7A&quot;&gt;
            &lt;bpmn2:dataInput id=&quot;_8C980097-4DBD-4BAF-B991-73EC1419E8CE_TaskNameInputX&quot; drools:dtype=&quot;Object&quot; itemSubjectRef=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_TaskNameInputXItem&quot; name=&quot;TaskName&quot;/&gt;
            &lt;bpmn2:dataInput id=&quot;_8C980097-4DBD-4BAF-B991-73EC1419E8CE_SkippableInputX&quot; drools:dtype=&quot;Object&quot; itemSubjectRef=&quot;__8C980097-4DBD-4BAF-B991-73EC1419E8CE_SkippableInputXItem&quot; name=&quot;Skippable&quot;/&gt;
            &lt;bpmn2:inputSet id=&quot;_Fdyq8AJMEDiMpvp3hRnB7A&quot;&gt;
              &lt;bpmn2:dataInputRefs&gt;_8C980097-4DBD-4BAF-B991-73EC1419E8CE_TaskNameInputX&lt;/bpmn2:dataInputRefs&gt;
              &lt;bpmn2:dataInputRefs&gt;_8C980097-4DBD-4BAF-B991-73EC1419E8CE_SkippableInputX&lt;/bpmn2:dataInputRefs&gt;
            &lt;/bpmn2:inputSet&gt;
          &lt;/bpmn2:ioSpecification&gt;
          &lt;bpmn2:dataInputAssociation id=&quot;_Fdyq8QJMEDiMpvp3hRnB7A&quot;&gt;
            &lt;bpmn2:targetRef&gt;_8C980097-4DBD-4BAF-B991-73EC1419E8CE_TaskNameInputX&lt;/bpmn2:targetRef&gt;
            &lt;bpmn2:assignment id=&quot;_Fdyq8gJMEDiMpvp3hRnB7A&quot;&gt;
              &lt;bpmn2:from xsi:type=&quot;bpmn2:tFormalExpression&quot; id=&quot;_Fdz5EAJMEDiMpvp3hRnB7A&quot;&gt;Task&lt;/bpmn2:from&gt;
              &lt;bpmn2:to xsi:type=&quot;bpmn2:tFormalExpression&quot; id=&quot;_Fd0gIAJMEDiMpvp3hRnB7A&quot;&gt;_8C980097-4DBD-4BAF-B991-73EC1419E8CE_TaskNameInputX&lt;/bpmn2:to&gt;
            &lt;/bpmn2:assignment&gt;
          &lt;/bpmn2:dataInputAssociation&gt;
          &lt;bpmn2:dataInputAssociation id=&quot;_Fd0gIQJMEDiMpvp3hRnB7A&quot;&gt;
            &lt;bpmn2:targetRef&gt;_8C980097-4DBD-4BAF-B991-73EC1419E8CE_SkippableInputX&lt;/bpmn2:targetRef&gt;
            &lt;bpmn2:assignment id=&quot;_Fd0gIgJMEDiMpvp3hRnB7A&quot;&gt;
              &lt;bpmn2:from xsi:type=&quot;bpmn2:tFormalExpression&quot; id=&quot;_Fd1HMAJMEDiMpvp3hRnB7A&quot;&gt;false&lt;/bpmn2:from&gt;
              &lt;bpmn2:to xsi:type=&quot;bpmn2:tFormalExpression&quot; id=&quot;_Fd1HMQJMEDiMpvp3hRnB7A&quot;&gt;_8C980097-4DBD-4BAF-B991-73EC1419E8CE_SkippableInputX&lt;/bpmn2:to&gt;
            &lt;/bpmn2:assignment&gt;
          &lt;/bpmn2:dataInputAssociation&gt;
        &lt;/bpmn2:userTask&gt;
        &lt;bpmn2:startEvent id=&quot;_3872BDA1-71C9-49B4-B15F-9800547FEA0A&quot;&gt;
          &lt;bpmn2:outgoing&gt;_D96968A8-096F-441E-BEF5-69B5EB7B1C91&lt;/bpmn2:outgoing&gt;
        &lt;/bpmn2:startEvent&gt;
      &lt;/bpmn2:process&gt;
      &lt;bpmndi:BPMNDiagram&gt;
        &lt;bpmndi:BPMNPlane bpmnElement=&quot;getting_started&quot;&gt;
          &lt;bpmndi:BPMNShape id=&quot;shape__3872BDA1-71C9-49B4-B15F-9800547FEA0A&quot; bpmnElement=&quot;_3872BDA1-71C9-49B4-B15F-9800547FEA0A&quot;&gt;
            &lt;dc:Bounds height=&quot;56&quot; width=&quot;56&quot; x=&quot;176&quot; y=&quot;319&quot;/&gt;
          &lt;/bpmndi:BPMNShape&gt;
          &lt;bpmndi:BPMNShape id=&quot;shape__8C980097-4DBD-4BAF-B991-73EC1419E8CE&quot; bpmnElement=&quot;_8C980097-4DBD-4BAF-B991-73EC1419E8CE&quot;&gt;
            &lt;dc:Bounds height=&quot;102&quot; width=&quot;154&quot; x=&quot;331&quot; y=&quot;296&quot;/&gt;
          &lt;/bpmndi:BPMNShape&gt;
          &lt;bpmndi:BPMNShape id=&quot;shape__3F791B0E-1549-441F-AA55-B70154E227B2&quot; bpmnElement=&quot;_3F791B0E-1549-441F-AA55-B70154E227B2&quot;&gt;
            &lt;dc:Bounds height=&quot;56&quot; width=&quot;56&quot; x=&quot;617&quot; y=&quot;319&quot;/&gt;
          &lt;/bpmndi:BPMNShape&gt;
          &lt;bpmndi:BPMNEdge id=&quot;edge_shape__3872BDA1-71C9-49B4-B15F-9800547FEA0A_to_shape__8C980097-4DBD-4BAF-B991-73EC1419E8CE&quot; bpmnElement=&quot;_D96968A8-096F-441E-BEF5-69B5EB7B1C91&quot;&gt;
            &lt;di:waypoint x=&quot;232&quot; y=&quot;347&quot;/&gt;
            &lt;di:waypoint x=&quot;331&quot; y=&quot;347&quot;/&gt;
          &lt;/bpmndi:BPMNEdge&gt;
          &lt;bpmndi:BPMNEdge id=&quot;edge_shape__8C980097-4DBD-4BAF-B991-73EC1419E8CE_to_shape__3F791B0E-1549-441F-AA55-B70154E227B2&quot; bpmnElement=&quot;_3B95A0A8-3313-487C-A14E-972E04D228B5&quot;&gt;
            &lt;di:waypoint x=&quot;485&quot; y=&quot;347&quot;/&gt;
            &lt;di:waypoint x=&quot;617&quot; y=&quot;347&quot;/&gt;
          &lt;/bpmndi:BPMNEdge&gt;
        &lt;/bpmndi:BPMNPlane&gt;
      &lt;/bpmndi:BPMNDiagram&gt;
      &lt;bpmn2:relationship id=&quot;_Fd2VUAJMEDiMpvp3hRnB7A&quot; type=&quot;BPSimData&quot;&gt;
        &lt;bpmn2:extensionElements&gt;
          &lt;bpsim:BPSimData&gt;
            &lt;bpsim:Scenario id=&quot;default&quot; name=&quot;Simulationscenario&quot;&gt;
              &lt;bpsim:ScenarioParameters/&gt;
              &lt;bpsim:ElementParameters elementRef=&quot;_3872BDA1-71C9-49B4-B15F-9800547FEA0A&quot;&gt;
                &lt;bpsim:TimeParameters&gt;
                  &lt;bpsim:ProcessingTime&gt;
                    &lt;bpsim:NormalDistribution mean=&quot;0&quot; standardDeviation=&quot;0&quot;/&gt;
                  &lt;/bpsim:ProcessingTime&gt;
                &lt;/bpsim:TimeParameters&gt;
              &lt;/bpsim:ElementParameters&gt;
              &lt;bpsim:ElementParameters elementRef=&quot;_8C980097-4DBD-4BAF-B991-73EC1419E8CE&quot;&gt;
                &lt;bpsim:TimeParameters&gt;
                  &lt;bpsim:ProcessingTime&gt;
                    &lt;bpsim:NormalDistribution mean=&quot;0&quot; standardDeviation=&quot;0&quot;/&gt;
                  &lt;/bpsim:ProcessingTime&gt;
                &lt;/bpsim:TimeParameters&gt;
                &lt;bpsim:ResourceParameters&gt;
                  &lt;bpsim:Availability&gt;
                    &lt;bpsim:FloatingParameter value=&quot;0&quot;/&gt;
                  &lt;/bpsim:Availability&gt;
                  &lt;bpsim:Quantity&gt;
                    &lt;bpsim:FloatingParameter value=&quot;0&quot;/&gt;
                  &lt;/bpsim:Quantity&gt;
                &lt;/bpsim:ResourceParameters&gt;
                &lt;bpsim:CostParameters&gt;
                  &lt;bpsim:UnitCost&gt;
                    &lt;bpsim:FloatingParameter value=&quot;0&quot;/&gt;
                  &lt;/bpsim:UnitCost&gt;
                &lt;/bpsim:CostParameters&gt;
              &lt;/bpsim:ElementParameters&gt;
            &lt;/bpsim:Scenario&gt;
          &lt;/bpsim:BPSimData&gt;
        &lt;/bpmn2:extensionElements&gt;
        &lt;bpmn2:source&gt;_3B7B4D14-4B20-497A-868A-D7B55CD93887&lt;/bpmn2:source&gt;
        &lt;bpmn2:target&gt;_3B7B4D14-4B20-497A-868A-D7B55CD93887&lt;/bpmn2:target&gt;
      &lt;/bpmn2:relationship&gt;
    &lt;/bpmn2:definitions&gt;
    </pre>

    Since we still have our app running using `mvn quarkus:dev`, when you make these changes and reload the endpoint, Quarkus will notice all of these changes and live-reload them, including changes in your business assets (i.e. processes, decision, rules, etc.).

    Check that it works as expected by opening the Swagger-UI endpoint by [clicking here](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/swagger-ui). The Swagger-UI will show the REST resources that have been generated from the project's _business assets_, in this case the `getting_started` resource, which is backed by our process definition (note that the sample _Greetings_ resource is also still shown in the Swagger UI).

    In the Swagger UI, expand the **POST /getting_started** resource. Click on the **Try it out** button on the right-hand-side of the screen. Click on the blue **Execute** button to fire the request. The response will be the instance-id/process-id of the created **getting_started** resource.

    ![Swagger](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/kogito-getting-started-swagger.png)

    Apart from the Swagger-UI, we can also call our RESTful resources from any REST client, for example via **cURL** in a terminal.

    Because the original Terminal tab already has our application running, we need to run this command in a second Terminal tab. Click on the following command to run it in your other Terminal tab. This will return the list of **getting_started** resource instances, which currently contains the single instance we created earlier:

    `curl -X GET "http://localhost:8080/getting_started" -H "accept: application/json"`

    > You can also open additional terminals with the "+" button on the tab bar to the right.
    > ![Open Terminal](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/katacoda-open-new-terminal.png)

    Our process defintion contains a *UserTask*. To retrieve the tasks of an instance, we need to execute another REST operation.

    Let's go back to the [Swagger-UI](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/swagger-ui). Expand the **GET ​/getting_started​/{id}​/tasks** operation, and click on the **Try it out** button. In the `id` field, fill in the value of the process instance id the previous command returned. Now, click on the **Execute** button.

    This will return a list of **Tasks**.

    ![Tasks](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/kogito-getting-started-get-tasks.png)

    Since we haven't defined any Task input and output data yet, we can simply complete the task without providing any data. We will again do this from the [Swagger-UI](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/swagger-ui). Expand the **POST ​/getting_started​/{id}​/Task/{workitemId}** operation, and click on the **Try it out** button. In the `id` field, fill in the value of the process instance id, and fill in the task-id that we retrieved with our previous REST call in the `workItemId` field. Now, click on the **Execute** button.

    This will complete the task, and the process will continue and reach the *End* node and complete.

    ![Complete Tasks](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/kogito-getting-started-complete-task.png)

    With the task completed, the process instance will now be completed. Execute the following command again in the Terminal by clicking on it. Notice that there are no process instances returned:

    `curl -X GET "http://localhost:8080/getting_started" -H "accept: application/json"`

    ## Congratulations!

    You've created your first Kogito application. You've defined a process in BPMN2, have seen the **live-reload** in action. You've experienced how Kogito automatically generates REST resources based on your process definition. Finally, you've started a process instance, retrieved the task list, completed a task and thereby finished the process instance.
  tabs:
  - title: Terminal 1
    type: terminal
    hostname: crc
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 100
- slug: 03-package-and-run
  id: 8szxiosknccj
  type: challenge
  title: Step 3
  assignment: |
    In the previous step you added a process definition to your Kogito application. Now it's time to package and run it as a self-contained JAR file.

    ### Stop the previous application

    Let's stop the original application so we can package and re-run it as an executable JAR. In the first terminal, press `CTRL-C` to stop the application.

    ### Package the app

    Package the application:

    ```
    mvn clean package
    ```. It produces 2 jar files:

    * `getting-started-1.0-SNAPSHOT.jar` - containing just the classes and resources of the projects, it’s the regular artifact produced by the Maven build.

    * `getting-started-1.0-SNAPSHOT-runner.jar` - being an executable jar. Be aware that it’s not an über-jar as the dependencies are copied into the `target/lib` directory.

    See the files with this command:

    ```
    ls -l target/*.jar
    ```

    ## Run the executable JAR

    You can run the packaged application by clicking:

    ```
    java -jar target/getting-started-1.0-SNAPSHOT-runner.jar
    ```

    We can test our application again using the second Terminal tab to create a new process instance by clicking on the following command:

    `curl -X POST "http://localhost:8080/getting_started" -H "accept: application/json" -H "Content-Type: application/json" -d "{}"`

    The output shows the id of the new instance (note that your id will be different from the one shown here)

    ```console
    {"id":"4844cfc0-ea93-46e3-8213-c10517bde1ce"}
    ```

    > When we're not running in `mvn quarkus:dev` mode, the Swagger UI is not available. It can however be enabled by adding the following configuration to your `src/main/resources/application.properties` file:
    >
    >  `quarkus.swagger-ui.always-include=true`


    > The `Class-Path` entry of the `MANIFEST.MF` file in the _runner JAR_ explicitly lists the jars from the `lib` directory. So if you want to deploy your application somewhere, you need to copy the _runner JAR_ as well as the _lib_ directory. If you want to create an _Uber-JAR_ with everything included, you can use `mvn package -DuberJar`.

    ## Cleanup

    Go back to the first terminal and stop the application once again by pressing `CTRL-C`.

    ## Congratulations!

    You've packaged up the Kogito app as an executable JAR and learned a bit more about the mechanics of packaging. In the next step, we'll continue our journey and build a _native image_. You will learn about the creation of a native executable and the packaging of such an executable in a Linux container.
  tabs:
  - title: Terminal 1
    type: terminal
    hostname: crc
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 100
- slug: 04-build-native
  id: ohx94yxgtx7a
  type: challenge
  title: Step 4
  assignment: |
    Let’s now produce a native executable for our application. It improves the startup time of the application, and produces a minimal disk footprint. The executable would have everything to run the application including the "JVM" (shrunk to be just enough to run the application), and the application.

    ![Native process](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/quarkus/native-image-process.png)

    We will be using GraalVM, which includes a native compiler for producing native images for a number of languages, including Java. It's been installed for you:

    ```
    echo $GRAALVM_HOME
    ```

    ## Build native image

    Within the `getting-started/pom.xml` is the declaration for the Quarkus Maven plugin which contains a profile for `native-image`:

    ```xml
    <profile>
      <id>native</id>
      <build>
        <plugins>
          <plugin>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-maven-plugin</artifactId>
            <executions>
              <execution>
                <goals>
                  <goal>native-image</goal>
                </goals>
              </execution>
            </executions>
          </plugin>
          <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-failsafe-plugin</artifactId>
            <version>${surefire.version}</version>
          </plugin>
        </plugins>
      </build>
    </profile>
    ```
    We use a profile because, you will see very soon, packaging the native image takes a few seconds. However, this compilation time is only incurred _once_, as opposed to _every_ time the application starts, which is the case with other approaches for building and executing JARs.

    In the original terminal, if the application is still running, stop it with ```
    Ctrl+C`. Next, create a native executable by clicking: `mvn clean package -Pnative -DskipTests=true
    ```

    > Since we are working in a Linux environment, and the OS that will eventually run our application is also Linux, we can use our local OS to build the native Quarkus app. If you need to build native Linux binaries when on other OS's like Windows or macOS, you can use `-Dquarkus.native.container-runtime=[podman | docker]`. You'll need either Docker or [Podman](https://podman.io) installed depending on which container runtime you want to use!

    This will take a couple of minutes to finish. Wait for it!

    In addition to the regular files, the build also produces `target/getting-started-1.0-SNAPSHOT-runner`. This is a native Linux binary:

    ```
    file target/getting-started-1.0-SNAPSHOT-runner
    ```

    ```console
    $ file target/getting-started-1.0-SNAPSHOT-runner
    target/getting-started-1.0-SNAPSHOT-runner: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=d8c36b6f114e5b2fce77b4efe07d1e4ac4879ab6, with debug_info, not stripped, too many notes (256)
    ```

    ## Run native image

    Since our environment here is Linux, you can _just run it_:

    ```
    target/getting-started-1.0-SNAPSHOT-runner
    ```

    Notice the amazingly fast startup time:

    ```console
    __  ____  __  _____   ___  __ ____  ______
     --/ __ \/ / / / _ | / _ \/ //_/ / / / __/
     -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\ \
    --\___\_\____/_/ |_/_/|_/_/|_|\____/___/
    2020-04-15 13:48:19,193 INFO  [io.quarkus] (main) getting-started 1.0-SNAPSHOT (powered by Quarkus 1.3.0.Final) started in 0.021s. Listening on: http://0.0.0.0:8080
    2020-04-15 13:48:19,193 INFO  [io.quarkus] (main) Profile prod activated.
    2020-04-15 13:48:19,193 INFO  [io.quarkus] (main) Installed features: [cdi, kogito, resteasy, resteasy-jackson, smallrye-openapi, swagger-ui]
    ```
    That's 21 milliseconds (twenty one!!!) to start a full business application, exposing a REST API and ready to serve requests in a shared learning environment!

    And extremely low memory usage as reported by the Linux `ps` utility. Click here to run this in your other Terminal tab:

    `ps -o pid,rss,command -p $(pgrep -f runner)`

    You should see something like:

    ```console
      PID   RSS COMMAND
    3003 26384 target/getting-started-1.0-SNAPSHOT-runner
    ```

    This shows that our process is taking around 27 MB of memory ([Resident Set Size](https://en.wikipedia.org/wiki/Resident_set_size), or RSS). Pretty compact!

    > Note that the RSS and memory usage of any app, including Quarkus, will vary depending your specific environment, and will rise as the application experiences load.

    Make sure the app is still working as expected by creating a new process instance:

    `curl -X POST "http://localhost:8080/getting_started" -H "accept: application/json" -H "Content-Type: application/json" -d "{}"`

    ```console
    $ curl -X POST "http://localhost:8080/getting_started" -H "accept: application/json" -H "Content-Type: application/json" -d "{}"
    {"id":"75c00bcc-97a5-4655-beee-9b0b7b320d19"}
    ```

    Nice!

    ## Cleanup

    Go to the first Terminal tab and press `CTRL-C` to stop our native app.

    ## Congratulations!

    You've now built a Kogito application as an executable JAR and a Linux native binary. Now let's give our app superpowers by deploying to OpenShift as a Linux container image.
  tabs:
  - title: Terminal 1
    type: terminal
    hostname: crc
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 100
- slug: 05-deploy-to-openshift
  id: bunphx9sbwlq
  type: challenge
  title: Step 5
  assignment: |
    Now that we have our app built, let's move it into containers and into the cloud.

    Make sure that you've stopped the Kogito application in your terminal with `CTRL-C`.

    ## Login to OpenShift

    **Red Hat OpenShift Container Platform** is the preferred container orchestration platform for Quarkus. OpenShift is based on **Kubernetes** which is the most used Orchestration platform for containers running in production.

    OpenShift also ships with a feature rich web console as well as command line tools to provide users with a nice interface to work with applications deployed to the platform.

    In order to login, we will use the **oc** command and then specify the server that we want to authenticate to:

    `oc login --server=https://[[HOST_SUBDOMAIN]]-6443-[[KATACODA_HOST]].environments.katacoda.com --insecure-skip-tls-verify=true`

    Enter your username and password:
    * Username: **developer**
    * Password: **developer**

    Congratulations, you are now authenticated to the OpenShift server.

    > If the above `oc login` command doesn't seem to do anything, you may have forgotten to stop the application from the previous
    step. Click in the first terminal and press CTRL-C to stop the application and try to `oc login` again!

    ## Access OpenShift Project

    [Projects](https://docs.openshift.com/container-platform/3.11/architecture/core_concepts/projects_and_users.html#projects) are a top level concept to help you organize your deployments. An OpenShift project allows a community of users (or a user) to organize and manage their content in isolation from other communities.

    For this scenario, let's create a project that you will use to house your applications. Click:

    `oc new-project kogito --display-name="Sample Kogito App"`

    **3. Open the OpenShift Web Console**

    OpenShift ships with a web-based console that will allow users to perform various tasks via a browser. To get a feel for how the web console works, click on the "OpenShift Console" tab next to the "Local Web Browser" tab.

    ![OpenShift Console Tab](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/quarkus/openshift-console-tab.png)

    > Note you will get a security certificate error due to the use of self-signed security certificates. You will need to accept the exception in your browser to continue to the OpenShift console.

    The first screen you will see is the authentication screen. Enter your username and password (u: developer, p: developer) and then log in:

    ![Web Console Login](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/login.png)

    After you have authenticated to the web console, you will be presented with a list of projects that your user has permission to work with.

    ![Web Console Projects](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/projects.png)

    Click on your new project name to be taken to the project overview page which will list all of the routes, services, deployments, and pods that you have running as part of your project:

    ![Web Console Overview](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/overview.png)

    There's nothing there now, but that's about to change.

    ## Deploy to OpenShift

    First, create a new _binary_ build within OpenShift:

    `oc new-build quay.io/quarkus/ubi-quarkus-native-binary-s2i:19.3.1 --binary --name=kogito-quickstart -l app=kogito-quickstart`

    > This build uses the new [Red Hat Universal Base Image](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/building_running_and_managing_containers/using_red_hat_universal_base_images_standard_minimal_and_runtimes), providing foundational software needed to run most applications, while staying at a reasonable size.

    And then start and watch the build, which will take about a minute or two to complete:

    `oc start-build kogito-quickstart --from-file=target/getting-started-1.0-SNAPSHOT-runner --follow`

    Once that's done, we'll deploy it as an OpenShift application:

    `oc new-app kogito-quickstart`

    and expose it to the world:

    `oc expose service kogito-quickstart`

    Finally, make sure it's actually done rolling out:

    `oc rollout status -w dc/kogito-quickstart`

    Wait for that command to report `replication controller "kogito-quickstart-1" successfully rolled out` before continuing.

    And now we can access our application using `cURL` once again:

    `curl -X POST "http://kogito-quickstart-kogito.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/getting_started" -H "accept: application/json" -H "Content-Type: application/json" -d "{}"`


    You should again see the id of the process instance we've just started:

    ```console
    {"id":"4844cfc0-ea93-46e3-8213-c10517bde1ce"}
    ```

    So now our app is deployed to OpenShift. You can also see it in the [Overview in the OpenShift Console](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/k8s/ns/kogito/deploymentconfigs/kogito-quickstart) with its single replica running in 1 pod (the blue circle).

    ## Congratulations!

    This step covered the deployment of a Kogito application on OpenShift. However, there is much more, and the integration with these environments has been tailored to make Kogito applications execution very smooth. For instance, the health extension can be used for [health check](https://access.redhat.com/documentation/en-us/openshift_container_platform/3.11/html/developer_guide/dev-guide-application-health); the configuration support allows mounting the application configuration using config maps, the metric extension produces data _scrape-able_ by [Prometheus](https://prometheus.io/) and so on.

    But we'll move to the final chapter around scaling and try a few things.
  tabs:
  - title: Terminal 1
    type: terminal
    hostname: crc
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 100
- slug: 06-scaling
  id: yvif2b9fomfb
  type: challenge
  title: Step 6
  assignment: |
    Now that we have our app running on OpenShift, let's see what we can do.

    ## Restrict resources

    Let's make _sure_ our Kogito app doesn't go beyond a reasonable amount of memory for each instance by setting _resource constraints_ on it. We'll go with 50 MB of memory as an upper limit (which is pretty thin, compared to your average Java app!). This will let us scale up quite a bit. Click here to set this limit:

    `oc set resources dc/kogito-quickstart --limits=memory=50Mi`

    ## Scale the app

    With that set, let's see how fast our app can scale up to 10 instances:

    `oc scale --replicas=10 dc/kogito-quickstart`

    Back in the [Overview in the OpenShift Console](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/k8s/ns/kogito/deploymentconfigs/kogito-quickstart) you'll see the app scaling dynamically up to 10 pods:

    ![Scaling](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/scaling.png)

    This should only take a few seconds to complete the scaling. Now that we have 10 pods running, let's hit it with some load:

    `for i in {1..50} ; do curl -X POST "http://kogito-quickstart-kogito.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/getting_started" -H "accept: application/json" -H "Content-Type: application/json" -d "{}" ; sleep .05 ; done`

    You can see the 10 instances of our Kogito app being load-balanced and process instances being created:

    ```console
    {"id":"dd26b837-0f45-46a3-89f3-919d89c92163"}
    {"id":"76300882-b02d-409a-b591-267c80544682"}
    {"id":"4b1ee26d-0cf9-48e5-a63c-1eb4af26941e"}
    {"id":"51e9cd7e-5753-4b4c-94cf-1caebc0792f5"}
    ...
    ```

    > For more fun with load balancing and apps, checkout the [Red Hat Developer Istio Tutorial](https://bit.ly/istio-tutorial) and learn how to control this with much greater precision and flexibility!

    10 not enough? Let's try 50:

    `oc scale --replicas=50 dc/kogito-quickstart`

    Back in the [Overview in the OpenShift Console](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/k8s/ns/kogito/deploymentconfigs/kogito-quickstart) you'll see the app scaling dynamically up to 50 pods:

    ![Scaling to 50](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-kogito/50pods.png)

    Once they are all up and running, try the same load again:

    `for i in {1..50} ; do curl -X POST "http://kogito-quickstart-kogito.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/getting_started" -H "accept: application/json" -H "Content-Type: application/json" -d "{}" ; sleep .05 ; done`

    And witness all 50 pods responding evenly to requests. Try doing that with your average Java app running in a container! This tutorial uses a single node OpenShift cluster, but in practice you'll have many more nodes, and can scale to hundreds or thousands of replicas if and when load goes way up.

    > 50 still not enough? Are you feeling lucky? Try **100**: `oc scale --replicas=100 dc/kogito-quickstart` and watch the magic on the [OpenShift Console](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/k8s/ns/kogito/deploymentconfigs/kogito-quickstart)

    ## Congratulations

    In this scenario you got a glimpse of the power of Kogito apps on a Quarkus runtime, both traditional JVM-based as well as native builds. There is much more to Kogito than fast startup times and low resource usage, so keep on exploring additional scenarios to learn more, and be sure to visit [kogito.kie.org](https://kogito.kie.org) to learn even more about the architecture and capabilities of this exciting new framework for Cloud Native Business Automation.
  tabs:
  - title: Terminal 1
    type: terminal
    hostname: crc
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 100
checksum: "2609839629744391632"
